# **해시 테이블**

<br>

해시 테이블은 파이썬의 딕셔너리처럼 **key를 통해 value에 직접 접근하는 자료구조**이다. 이렇게 key를 통해 찾고자 하는 값에 직접 접근하기 때문에 데이터를 검색, 삽입, 삭제하는 데 시간복잡도는 O(1)이 걸린다.

<br>

## **1.해시 함수와 해시**

<br>

해시 테이블을 이해하려면 해시 함수와 해시가 무엇인지 알아야한다.

해시 함수는 **임의의 길이를 가진 데이터가 주어졌을때 이를 고유한 값(고정된 길이의)으로 반환하는 함수이다.** 예를 들어 `10, 11, 12` 라는 데이터가 있을때 `데이터를 10으로 나누고 나머지를 반환한다`라는 해시 함수에 입력하면 출력값은 `0, 1, 2` 으로 나오게 될 것이다. 이때 해시 함수를 통해 나온 값인 `0, 1, 2` 를 **해시**라고 한다. **해시 테이블은 이 해시값을 인덱스로 활용하여 데이터를 저장하는데 이때 저장되는 공간을 bucket이라고 한다.**

<br>

![hash_table](https://user-images.githubusercontent.com/89771322/152672246-678a7d9a-32a5-46a3-a510-75552de0c676.png)<br>
[출처](![hash_table](https://user-images.githubusercontent.com/89771322/152672246-678a7d9a-32a5-46a3-a510-75552de0c676.png)
)

<br>

*위 그림의 경우 Jogn Smith라는 키가 해시 함수를 통과하여 02로 반환되었고 이를 인덱스로 활용하여 데이터를 저장한 것이다.*

<br>

## **2. 해시 충돌**

<br>

만약 `10, 11, 21, 20, 30, 12, 13, 14, 15, 16`라는 데이터를 길이가 10인 해시 테이블에 저장하는 과정을 생각해보자. 이때 우리가 선택한 해시 함수는 `key % 해시테이블의 길이`이다. 이 경우 해시는 `0, 1, 1, 0, 0, 2, 3, 4, 5, 6`이렇게 나오게 된다. 즉, 10과 20, 30 또 11, 21 다른 key값인데 해시는 같은 값으로 나오게 된다. 이런 경우를 해시 충돌이라고 한다. 이렇게 해시 충돌이 일어나는 경우 해시 테이블의 효율성이 떨어지기에 해시 테이블의 중요한 목적 중 하나는 해시 충돌이 덜 일어나는 해시 함수를 만드는 것이다.

하지만, 해시 함수를 아무리 잘 만들어도 해시 테이블의 크기 자체가 작다면 충돌은 일어날 수 밖에 없다. 이를 위해 충돌이 일어났을때 해결하는 방법들이 존재한다.

<br>

### ***체이닝(Chaining)***

<br>

![chaining](https://user-images.githubusercontent.com/89771322/152672675-68bc999b-be21-4e0f-89fb-4e93057a4a0c.png)<br>
[출처](http://wiki.hash.kr/index.php/%ED%95%B4%EC%8B%9C%EC%B6%A9%EB%8F%8C)

체이닝은 위 그림처럼 **연결리스트를 활용하여 충돌이 일어난 경우 리스트로 연결하는 형태로 충돌을 해결하는 방법**이다.

<br>

### ***오픈 어드레싱(Open addressing)***

<br>

![Open adre](https://user-images.githubusercontent.com/89771322/152672881-485cd809-4d18-4235-aca3-4020f125869f.png)<br>
[출처](https://en.wikipedia.org/wiki/Open_addressing)

오픈 어드레싱의 경우 충돌이 일어났을 때 **비어있는 공간을 탐색하여 충돌을 해결하는 방법이다.** 위 그림의 경우 Sandra Dee의 해시 값이 John Smith의 해시값과 충돌하여 비어 있는 곳에 key와 value값을 저장한 것이다.

<br>

## **3. 체이닝 vs 오픈 어드레싱**

<br>

![c vs o](https://user-images.githubusercontent.com/89771322/152673330-c1274654-62a0-43f6-8dd5-eca8b031f403.png)

체이닝은 테이블이 어느 정도 채워지더라도 **성능 저하가 선형적**으로 일어난다. 또한 삭제가 간단하기에 **삭제 작업이 간단해서 삭제가 빈번히 일어난다면 체이닝을 선택하는 게 좋다고 한다.** 또한 오픈 어드레싱의 경우 **클러스팅 문제 즉, 데이터가 특정 지역에 몰리는 현상도 고려해야하기 때문에 구현이 어렵지만** 체이닝의 경우 충돌의 최소화만 신경쓰면 되기에 **비교적 구현이 쉽다.**
> 그림에서 Load factor는 해시 테이블에 할당된 키의 개수를 전체 인덱스 개수로 나눈 것이다. 즉, 해시 테이블이 얼마나 차있는지를 나타낸다. 

반면, 오픈 어드레싱의 경우 체이닝 처럼 충돌을 해결하기 위해 **추가적인 메모리를 사용할 필요가 없다.** 또한 데이터가 **캐시 라인을 잘 활용할 수 있을 정도의 크기라면 좋은 성능**을 낼 수 있다고 한다. 하지만, 테이블의 높은 L**oad factor가 예상된다면, 오픈 어드레싱 방법을 사용하는 건 적절하지 않은 선택이다.**

<br>
<br>
<hr>

### *참고자료*
http://egloos.zum.com/sweeper/v/925740 <br>
https://blog.weirdx.io/post/5270 <br>
https://mangkyu.tistory.com/102
