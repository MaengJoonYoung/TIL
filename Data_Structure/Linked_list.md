# **연결 리스트**

<br>

연결 리스트는 **ADT(추상 자료형)으로 여러 node들이 연결된 자료구조이다.** 여기서 ADT는 추상적으로 필요한 기능을 적어놓은 설명서라고 할 수 있다. **즉, 실체가 없는 것이기에 해당 설명서를 보고 사용자가 구현해야하는 것이다.**

<br>

## **1. 연결 리스트 구조**

<br>

![연결 리스트](https://user-images.githubusercontent.com/89771322/150989068-84d3d9d9-f42a-4dd0-9a7d-5b0070ad42c7.png)

<br>

연결 리스트는 말 그대로 **어떤 것을 연결한 자료구조**인데, 여기서 어떤 것은 **Node**를 말한다. 연결 리스트는 위 그림과 같이 구성되어 있는데, 각 Node는 **데이터를 담는 부분**과 **다음 Node와 연결해주는 부분**으로 구성되어 있다.

그림처럼 첫번째 Node를 **Head**라고 표현하고 마지막 끝에 있는 노드를 **Tail**이라고 표현한다.
> Tail node에서 다음 node와 연결해주는 부분은 None과 연결되어 있다. 즉, 아무와도 연결되어 있지 않다.

<br>

## **2. 연결 리스트에서 데이터 추가/삭제**

<br>

연결 리스트에서는 데이터를 추가하거나 삭제할때 각 node에서 다음 node를 **가르키는 화살표만 바꾸면 된다.**

*예를 들어 `1 → 2 → 3 → 5` 라는 단방향 연결 리스트가 있을때, 3과 5 사이에 4라는 데이터를 추가하면 다음과 같은 과정을 거친다.*

<br>

1. head(1번)에서 시작해 물어 물어가며 3번까지 이동한다.
2. 4라는 데이터를 가진 node를 만든다.
3. 3번의 화살표가 4번을 가르키게 한다. (3 → 4)
4. 4번의 화살표가 5번을 가르키게 한다. (4 → 5)

*이렇게 만들어진 `1 → 2 → 3 → 4 → 5` 라는 데이터에서 4라는 데이터를 가진 node를 삭제하는 과정은 다음과 같다.*

<br>

1. 삭제하고자 하는 데이터가 head(1번)에 없다면, 각 node의 다음 node가 가진 데이터가 4인지 확인하며 이동.
2. 3번 다음의 node의 데이터가 4인 것을 확인 
3. 3번 화살표가 5번을 가르키게 한다. (3 → 5)
4. 4번을 삭제한다.
> 삭제하고자 하는 데이터가 head에 있다면 head를 삭제하면 된다.

<br>

***이렇게 데이터를 추가하고 삭제하는 과정을 배열과 비교해보자.***

배열의 경우 중간에 데이터를 추가하면 그 뒤에 있던 데이터들을 다 뒤로 미루고 데이터를 추가한다. 삭제의 경우도 데이터가 삭제된 공간을 채우기 위해 뒤에 있는 데이터의 자리를 하나씩 앞으로 이동시키는 과정을 거친다.

즉, 배열과 비교했을 때 연결 리스트는 **추가와 삭제가 더 용이하다는 장점이 있다.** 하지만, 데이터를 추가하고 삭제하는 1번 과정을 보면 알 수 있듯이, 데이터에 접근하는 과정은 **첫번째 데이터부터 시작해서 순차적으로 진행이 된다.** 그렇기에 데이터의 **인덱스를 활용해 접근하는 배열에 비해 데이터에 접근하는 것은 더 느리다고 볼 수 있다.**

<br>

## **3. 연결 리스트 종류**

<br>

* 단방향 연결 리스트
  * node를 가르키는 포인터가 다음 node의 정보만을 가지고 있다.
* 양방향 연결 리스트
  * 포인터가 다음 node와 이전 node의 정보를 다 가지고 있다.
* 원형 연결 리스트
  * Tail node가 Head node의 정보를 가지고 있다.

<br>

## **4. 연결 리스트 vs 배열**

<br>

연결 리스트와 배열은 각각 상반되는 장점과 단점을 가지고 있는데, 이는 다음과 같다.

<br>

* 연결 리스트
  * 장점
    * 리스트의 길이를 정해주지 않기에 데이터 개수에 제한이 없다.
    * 데이터의 추가/삭제가 빠르다.
  * 단점
    * 데이터를 탐색할 때 순차적으로 진행하기에 탐색이 오래 걸린다.

>데이터의 추가/삭제가 자주 발생하고 데이터의 탐색이 잘 이뤄지지 않는 경우에 사용하면 좋다.

<br>

* 배열
  * 장점
    * index를 통해 데이터를 탐색하기가 매우 빠르다. (index를 통해 찾을 경우, 원하는 데이터 값을 통해 찾을 경우 순차적으로 찾는다.)
  * 단점
    * 데이터의 크기가 정해져있다.
    * 데이터의 추가/삭제가 불편하다.

> 들어올 데이터의 크기를 어느정도 알고 있고 index를 통한 탐색이 많은 경우, 또한 데이터의 추가/삭제가 많이 일어나지 않는 경우에 사용하면 좋다.

