## **Dynamic Programming & Greedy**

<br>


DP(동적 계획법)와 Greedy(탐욕 알고리즘)은 BFS나 DFS 처럼 구현하는 알고리즘이 아니라 **문제를 해결하는 하나의 방법론**이라고 할 수 있다.

<br>

## **1. Dynamic Programming(동적 계획법)**

<br>

DP는 해결하고자 하는 문제를 **작은 문제로 분할하여 해결한 후 이 결과를 재활용 하는 방법**이다. 즉, 한번 해결한 문제는 다시 풀지 않는 방법이다. 큰 문제를 작은 문제로 분할하고 이를 해결하는 방식으로 문제를 해결하는 것이 분할정복과 유사하지만, **분할정복의 경우 나눠진 작은 문제들이 이미 해결한 문제더라도 다시 해결하지만,** 동적 계획법은 **이미 해결한 문제는 다시 해결하지 않는 다는 점**에서 차이가 있다.

<br>

![동적 프로그래밍](https://user-images.githubusercontent.com/89771322/153138934-7feebfb9-71ce-4f0f-80be-f42df594190e.png)

<br>

분할정복 방법으로 위의 피보나치 수열을 구하는 문제를 재귀적으로 해결하는 과정은 다음과 같다.

* 분할정복과 재귀
  * 피보나치 수열의 5번째 수를 구하기 위해  4번째를 구하고 3번째를 구하는 문제로 나눈다.
  * 4번째를 구하기 위해 3번째를 구하고 2번째를 구하는 문제로 나눈다.
  * 이를 쭉 반복한 뒤 아래서부터 하나씩 문제를 해결해간다.

이렇게 분할정복을 통해 문제를 해결하면 2번째 수를 구하는 문제는 **3번** 해결하고, 3번째 수를 구하는 문제는 **2번** 반복된다. 즉, 필요없는 연산을 중복해서 실시하는 것이다. **동적 계획법을 사용하면 이러한 중복 연산을 피할 수 있다.**

<br>

### ***메모이제이션(Memoization), 타뷸레이션(Tabulation)***

<br>

동적 계획법으로 중복적인 연산을 피하는 대표적인 방법으로는 메모이제이션과, 타뷸레이션이 있다.

<br>

### *메모이제이션*

<br>

메모이제이션의 핵심은 해결한 문제를 **메모**해두고 똑같은 문제를 다시 해결해야될 때가 오면 **메모에 적혀있는 정답을 활용**하는 것이다.

메모이제이션은 위에서 아래로 내려가는 **하향식 방법**인데, 우선 가장 큰 문제를 해결하려고 시도한다. 이때 이 문제를 해결하기 위한 작은 문제들에 접근하여 이 문제들을 해결하려고 시도하는 과정을 반복하면서 점점 내려가기에 하향식 방법이라고 한다. 문제를 다 분할하면 하나씩 해결하면서 해결한 결과를 메모에 적어두고 활용하는 방식으로 최종적인 문제를 해결하는 방법이 바로 메모이제이션이다.

<br>

### *타뷸레이션*

<br>

타뷸레이션은 메모이제이션과 반대로 아래에서부터 위로 올라가는 상향식 방법이다. 즉, **가장 작은 문제부터 하나씩 차근차근 해결해나가는 방식**이다. 만약 피보나치 수열을 5번째 수 타뷸레이션으로 구한다면 그 과정은 다음과 같다.

1. 첫번째 항과 두번째 항의 값은 1
2. 세번째 항을 구하기 위해 구해둔 첫번째항과 두번째 항을 이용.
3. 네번째 항을 구하기 위해 세번째 항과 두번째 항을 이용.
4. 다섯번째 항을 구하기 위해 네번째 항과 세번째 항을 이용.

<br>

***메모이제이션과 타뷸레이션으로 피보나치 수열 문제를 해결하는 코드는 다음과 같이 작성할 수 있다.***

<br>

```python
# 메모이제이션
def memoization(num, memo ={}):
    # 편의상 0번째 항을 추가하여 0으로 지정
    if num == 0:
        return 0
    if num == 1:
        return 1
    # 저장되어 있는 값인 경우 메모에서 가져온다.
    if num in memo:
        return memo[num]
    
    memo[num] = memoization(num-1, memo) + memoization(num-2, memo)

    return memo[num]
```

<br>

```python
# 타뷸레이션
def tabulation(num):
    
    fibo =[0, 1]
    for i in range(2,num+1):
        fibo.append(fibo[i-1] + fibo[i-2])
    return fibo[num]
```

<br>

## **2. Greedy(탐욕 알고리즘)**

<br>

![Greedy](https://user-images.githubusercontent.com/89771322/153205650-82b3a5f9-0e59-4b3d-a784-113ed16d65cc.gif)
[출처](https://brilliant.org/wiki/greedy-algorithm/)

<br>

Greedy 방법은 **지금 당장 해결하려는 문제의 최선만 생각하며 해결하는 방식**이다. 위 그림처럼 Greedy 방법으로 구한 답이 **최종적인 문제의 최선은 아닐 수도 있다.** 

<br>

Greedy 방법을 사용하는 예시로 대표적인 문제는 잔돈을 거슬러 주는 문제이다. 만약 800원을 동전의 금액에 상관없이 최소 개수로 나눠줘야 하는데, 가지고 있는 동전은 500원, 400원, 100원 짜리이다. *(물론 400원짜리 동전은 없지만, 설명을 위해 가정)* 동전을 최소한으로 주기 위해서는 **400원짜리 동전을 2개**주면 되지만, Greedy 방법으로 해결한다면 거슬러줘야 하는 돈을 최대로 줄이기 위해 500원을 먼저 주고 100원 짜리를 3개 줘서 **총 4개의 동전**을 써야한다. **위에서 말했듯이 Greedy 방법으로 내린 결정은 최종적인 문제에서 최선의 결정이 아닐수도 있다.**

<br>

***그렇다면 Greedy 방법은 언제 사용하는게 좋을까?***

만약 우리가 풀고자 하는 문제가 그**때 그때 최선의 선택을 하는 것으로 최적의 정답을 구할 수 있는 문제**라면 적절할 것이다. 또는 **시간이나 공간적인 제약으로 인해 최종적인 문제의 최선을 찾기 너무 힘든 경우** 어느정도의 타협을하고 Greedy 방법을 사용한다면 빠른 시간에 최선과 가까운 답을 낼 수도 있다고 한다.

<br>
<br>
<hr>

### *참고자료*

https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98<br>
https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95<br>
https://velog.io/@nninnnin7/Dynamic-programming-1