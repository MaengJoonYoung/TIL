# SQL(Structured Query Language)*


<br>

***SQL을 풀네임을 읽어나가며 설명해보자.***

<br>
<br>

### **1-1. Structured**

 
<br>

SQL은 데이터베이스, 그 중에서도 ***관계형 데이터 베이스와 소통하기 위한 프로그래밍 언어***이다. 풀네임에 있는 'Structured'에서 느낄 수 있듯이 데이터 구조가 고정되어 있는 데이터베이스에 사용 가능하다.

 <br>

*그렇다면 관계형 데이터베이스란 무엇일까?*

<br>

→ 관계형 데이터베이스는 영어로 하면 'relational databased'이다. 여기서 테이블이라는 단어가 등장하는데, 구조화된 데이터 하나를 '테이블'이라고 표현하고 이렇게 사전에 정의된 테이블을 'relation'이라고 부르기도 한다. 이러한 이유로 관계형 데이터베이스(relational databased)라 부른다.

<br>

***정리하자면, 관계형 데이터베이스는 구조화된 데이터인 테이블을 사용하는 데이터베이스이고 이러한 관계형 데이터베이스와 소통하는 언어가 바로 SQL이다.***

<br>
<br>

### **1-2. Query**

<br> 

쿼리는 저장되어 있는 데이터를 필터 하기 위한 **질문**이라고 생각하면 된다. 예를 들자면, 우리가 검색을 할 때 검색어가 일종의 쿼리라고 볼 수 있다. 인터넷이라는 방대한 정보가 저장되어 있는 곳에 내가 궁금한 '서대문구 맛집'을 검색하는 건 맛집과 관련된 수많은 데이터 중 서대문구에 있는 맛집 정보를 얻기 위한 행동이기 때문이다.

<br>

***즉, SQL은 관계형 데이터베이스에 '혹시, 이런 데이터 있니? 있으면 좀 줄래?'라고 질문을 하는 것이라고 볼 수 있다.***

<br>
<br>
<hr>

<br>


## *2. 관계형 데이터베이스의 관계 종류*

<br>

관계 종류는 여러 가지가 있는데 오늘 배운 건 아래에 있는 4가지이다.

<br>

1. 일대일 관계.
2. 일대다 관계.
3. 다대다 관계.
4. 자기 참조 관계.

<br>

### *2-1. 일대일 관계*

<br>

일대일 관계는 테이블 레코드 하나가 다른 테이블의 한 레코드와 연결되어 있는 것이다. 연인관계를 생각해보자. 연인이라면 남자의 경우 한 명의 여자 친구와 연결되어 있고 여자의 경우도 마찬가지로 한 명의 남자 친구와 연결되어 있다.

<br>

### *2-2 일대다 관계.*

<br>

일대다 관계는 테이블 레코드 하나가 다른 테이블의 여러 레코드와 연결되어 있는 것이다. 예를 들어 우리가 여태까지 산 신발들을 생각해보자. 나는 신발들의 주인으로서 다양한 신발을 소유할 수 있지만, 각각의 신발들의 주인은 오직 나 하나이다.

<br>

### *2-3 다대다 관계.*

<br>

다대다 관계는 여러 개의 레코드가 여러개의 레코드와 연결된 것이다. 예를 들어 온라인 쇼핑을 할 때 우리는 다양한 상품을 구매할 수 있고 상품의 입장에서도 고객이 나만 있는 것이 아니라 다양한 사람들이 해당 상품의 고객이 될 수 있다. 이런 다대다 관계를 관리하기 위해서는 각 테이블에 일대다 관계를 형성하는 새로운 테이블인 '조인 테이블'을 만들어서 관리한다.

<br>

### *2-4. 자기 참조 관계.*

<br>

자기참조 관계는 일대다 관계가 다른 테이블과 이루어진 것이 아니라 한 테이블 내에서 이루어진 것이라고 생각하면 된다. 예를 들어 우리가 어느 사이트에 회원가입을 할 때 추천인을 입력하는 경우를 생각해보자. 각 유저가 선택할 수 있는 추천인은 한 명이지만 추천인은 한 명의 유저가 중복되어 선택될 수 있다.

<br>
<hr>
<br>

## **3. SELECT 실행 순서**

<br>


*쿼리문은 적힌 순서대로 실행되는 것이 아니라 정해진 순서되로 사용되는데, 실행 순서는 다음과 같다. FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY*

<br>

~~~sql
SELECT CustomerId, AVG(Total)
FROM invoices
WHERE CustomerId >= 10
GROUP BY CustomerId
HAVING SUM(Total) >= 30
ORDER BY 2 ;
~~~

<br>

위와 같은 경우 실행 순서는 아래와 같다

<br>

*1. FROM : invoices라는 테이블에 접근*

*2. WHERE : customerid가 10 이상인 레코드를 조회*

*3. GROUP BY : customoerid를 기준으로 그룹화*

*4. HAVING : total의 합계가 30이 넘는 데이터 조회*

*5. SELECT : 조회된 레코드에서 customerid와 total의 평균값을 가져온다*

*6. ORDER BY : total의 평균값을 기준으로 오름차순으로 정렬한다.*

<br>

이 실행순서를 지키지 않는 경우 오류가 발생한다.

<br>

~~~sql
SELECT CustomerId, Total
FROM invoices
GROUP BY CustomerId
WHERE CustomerId >= 10
~~~

<br>

이러한 경우 WHERE가 GROUP BY 이전에 실행되어야 하는데 순서가 밑에 있기에 오류가 발생한다.

<br>

## **4. 서브쿼리**

<br> 

*쿼리문을 작성할 때 다른 쿼리문을 포함하는 것이 서브쿼리(SUBQUERY)이고 서브쿼리는 소괄호 안에 감싸져 있다.*

<br>

~~~sql
SELECT t.Name FROM tracks t 
WHERE t.AlbumId IN 
(SELECT a.AlbumId FROM albums a 
WHERE a.Title IN ('Unplugged', 'Outbreak'));
~~~

<br>

해당 쿼리는 tracks라는 테이블의 AlbumID 중 Title에 'Unplugged', 'Outbreak'가 포함되어 있는 AlbumID를 조회하여 트랙의 이름을 가져온 쿼리문이다. **이를 위해 albums라는 테이블에서 title에 'Unplugged', 'Outbreak' 포함되어 있는 AlbumID를 가져오는 서브쿼리를 사용한 것이다.**